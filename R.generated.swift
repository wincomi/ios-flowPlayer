//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 3 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `Main`.
    static let main = _R.storyboard.main()
    /// Storyboard `SongInfo`.
    static let songInfo = _R.storyboard.songInfo()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Main", bundle: ...)`
    static func main(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.main)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "SongInfo", bundle: ...)`
    static func songInfo(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.songInfo)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.file` struct is generated, and contains static references to 1 files.
  struct file {
    /// Resource file `Settings.bundle`.
    static let settingsBundle = Rswift.FileResource(bundle: R.hostingBundle, name: "Settings", pathExtension: "bundle")

    /// `bundle.url(forResource: "Settings", withExtension: "bundle")`
    static func settingsBundle(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.settingsBundle
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 1 images.
  struct image {
    /// Image `Close`.
    static let close = Rswift.ImageResource(bundle: R.hostingBundle, name: "Close")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "Close", bundle: ..., traitCollection: ...)`
    static func close(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.close, compatibleWith: traitCollection)
    }
    #endif

    /// This `R.image.contextualAction` struct is generated, and contains static references to 5 images.
    struct contextualAction {
      /// Image `favorite`.
      static let favorite = Rswift.ImageResource(bundle: R.hostingBundle, name: "ContextualAction/favorite")
      /// Image `info`.
      static let info = Rswift.ImageResource(bundle: R.hostingBundle, name: "ContextualAction/info")
      /// Image `play`.
      static let play = Rswift.ImageResource(bundle: R.hostingBundle, name: "ContextualAction/play")
      /// Image `remove`.
      static let remove = Rswift.ImageResource(bundle: R.hostingBundle, name: "ContextualAction/remove")
      /// Image `shuffle`.
      static let shuffle = Rswift.ImageResource(bundle: R.hostingBundle, name: "ContextualAction/shuffle")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "favorite", bundle: ..., traitCollection: ...)`
      static func favorite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.contextualAction.favorite, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "info", bundle: ..., traitCollection: ...)`
      static func info(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.contextualAction.info, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "play", bundle: ..., traitCollection: ...)`
      static func play(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.contextualAction.play, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "remove", bundle: ..., traitCollection: ...)`
      static func remove(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.contextualAction.remove, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "shuffle", bundle: ..., traitCollection: ...)`
      static func shuffle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.contextualAction.shuffle, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.likedState` struct is generated, and contains static references to 3 images.
    struct likedState {
      /// Image `Dislike`.
      static let dislike = Rswift.ImageResource(bundle: R.hostingBundle, name: "LikedState/Dislike")
      /// Image `Love Filled`.
      static let loveFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "LikedState/Love Filled")
      /// Image `Love`.
      static let love = Rswift.ImageResource(bundle: R.hostingBundle, name: "LikedState/Love")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Dislike", bundle: ..., traitCollection: ...)`
      static func dislike(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.likedState.dislike, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Love Filled", bundle: ..., traitCollection: ...)`
      static func loveFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.likedState.loveFilled, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Love", bundle: ..., traitCollection: ...)`
      static func love(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.likedState.love, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.settings` struct is generated, and contains static references to 15 images.
    struct settings {
      /// Image `AlignLeft`.
      static let alignLeft = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/AlignLeft")
      /// Image `Cloud`.
      static let cloud = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Cloud")
      /// Image `Donate`.
      static let donate = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Donate")
      /// Image `Equalizer`.
      static let equalizer = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Equalizer")
      /// Image `Faq`.
      static let faq = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Faq")
      /// Image `IncreaseFont`.
      static let increaseFont = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/IncreaseFont")
      /// Image `Info`.
      static let info = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Info")
      /// Image `Lock`.
      static let lock = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Lock")
      /// Image `Love`.
      static let love = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Love")
      /// Image `Send`.
      static let send = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Send")
      /// Image `Shutdown`.
      static let shutdown = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Shutdown")
      /// Image `SleepTimer`.
      static let sleepTimer = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/SleepTimer")
      /// Image `Tap`.
      static let tap = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Tap")
      /// Image `Unlock`.
      static let unlock = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Unlock")
      /// Image `settings`.
      static let settings = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/settings")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "AlignLeft", bundle: ..., traitCollection: ...)`
      static func alignLeft(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.alignLeft, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Cloud", bundle: ..., traitCollection: ...)`
      static func cloud(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.cloud, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Donate", bundle: ..., traitCollection: ...)`
      static func donate(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.donate, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Equalizer", bundle: ..., traitCollection: ...)`
      static func equalizer(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.equalizer, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Faq", bundle: ..., traitCollection: ...)`
      static func faq(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.faq, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "IncreaseFont", bundle: ..., traitCollection: ...)`
      static func increaseFont(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.increaseFont, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Info", bundle: ..., traitCollection: ...)`
      static func info(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.info, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Lock", bundle: ..., traitCollection: ...)`
      static func lock(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.lock, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Love", bundle: ..., traitCollection: ...)`
      static func love(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.love, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Send", bundle: ..., traitCollection: ...)`
      static func send(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.send, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Shutdown", bundle: ..., traitCollection: ...)`
      static func shutdown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.shutdown, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "SleepTimer", bundle: ..., traitCollection: ...)`
      static func sleepTimer(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.sleepTimer, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Tap", bundle: ..., traitCollection: ...)`
      static func tap(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.tap, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Unlock", bundle: ..., traitCollection: ...)`
      static func unlock(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.unlock, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "settings", bundle: ..., traitCollection: ...)`
      static func settings(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.settings.settings, compatibleWith: traitCollection)
      }
      #endif

      /// This `R.image.settings.gesture` struct is generated, and contains static references to 4 images.
      struct gesture {
        /// Image `Left`.
        static let left = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Gesture/Left")
        /// Image `Right`.
        static let right = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Gesture/Right")
        /// Image `Tap`.
        static let tap = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Gesture/Tap")
        /// Image `Volume`.
        static let volume = Rswift.ImageResource(bundle: R.hostingBundle, name: "Settings/Gesture/Volume")

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Left", bundle: ..., traitCollection: ...)`
        static func left(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.settings.gesture.left, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Right", bundle: ..., traitCollection: ...)`
        static func right(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.settings.gesture.right, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Tap", bundle: ..., traitCollection: ...)`
        static func tap(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.settings.gesture.tap, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Volume", bundle: ..., traitCollection: ...)`
        static func volume(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.settings.gesture.volume, compatibleWith: traitCollection)
        }
        #endif

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    /// This `R.image.sort` struct is generated, and contains static references to 15 images.
    struct sort {
      /// Image `Album Artist`.
      static let albumArtist = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Album Artist")
      /// Image `Album Title`.
      static let albumTitle = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Album Title")
      /// Image `Artist`.
      static let artist = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Artist")
      /// Image `Ascending`.
      static let ascending = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Ascending")
      /// Image `Composer`.
      static let composer = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Composer")
      /// Image `Date Added`.
      static let dateAdded = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Date Added")
      /// Image `Descending`.
      static let descending = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Descending")
      /// Image `Genre`.
      static let genre = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Genre")
      /// Image `Last Played Date`.
      static let lastPlayedDate = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Last Played Date")
      /// Image `Play Count`.
      static let playCount = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Play Count")
      /// Image `Playback Duration`.
      static let playbackDuration = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Playback Duration")
      /// Image `Rating`.
      static let rating = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Rating")
      /// Image `Title`.
      static let title = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Title")
      /// Image `Year`.
      static let year = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/Year")
      /// Image `default`.
      static let `default` = Rswift.ImageResource(bundle: R.hostingBundle, name: "Sort/default")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Album Artist", bundle: ..., traitCollection: ...)`
      static func albumArtist(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.albumArtist, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Album Title", bundle: ..., traitCollection: ...)`
      static func albumTitle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.albumTitle, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Artist", bundle: ..., traitCollection: ...)`
      static func artist(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.artist, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Ascending", bundle: ..., traitCollection: ...)`
      static func ascending(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.ascending, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Composer", bundle: ..., traitCollection: ...)`
      static func composer(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.composer, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Date Added", bundle: ..., traitCollection: ...)`
      static func dateAdded(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.dateAdded, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Descending", bundle: ..., traitCollection: ...)`
      static func descending(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.descending, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Genre", bundle: ..., traitCollection: ...)`
      static func genre(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.genre, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Last Played Date", bundle: ..., traitCollection: ...)`
      static func lastPlayedDate(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.lastPlayedDate, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Play Count", bundle: ..., traitCollection: ...)`
      static func playCount(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.playCount, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Playback Duration", bundle: ..., traitCollection: ...)`
      static func playbackDuration(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.playbackDuration, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Rating", bundle: ..., traitCollection: ...)`
      static func rating(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.rating, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Title", bundle: ..., traitCollection: ...)`
      static func title(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.title, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Year", bundle: ..., traitCollection: ...)`
      static func year(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.year, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "default", bundle: ..., traitCollection: ...)`
      static func `default`(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.sort.`default`, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.statusAlert` struct is generated, and contains static references to 4 images.
    struct statusAlert {
      /// Image `check`.
      static let check = Rswift.ImageResource(bundle: R.hostingBundle, name: "StatusAlert/check")
      /// Image `remove`.
      static let remove = Rswift.ImageResource(bundle: R.hostingBundle, name: "StatusAlert/remove")
      /// Image `skipToNextItem`.
      static let skipToNextItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "StatusAlert/skipToNextItem")
      /// Image `skipToPreviousItem`.
      static let skipToPreviousItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "StatusAlert/skipToPreviousItem")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "check", bundle: ..., traitCollection: ...)`
      static func check(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.statusAlert.check, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "remove", bundle: ..., traitCollection: ...)`
      static func remove(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.statusAlert.remove, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "skipToNextItem", bundle: ..., traitCollection: ...)`
      static func skipToNextItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.statusAlert.skipToNextItem, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "skipToPreviousItem", bundle: ..., traitCollection: ...)`
      static func skipToPreviousItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.statusAlert.skipToPreviousItem, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.tabGlypics` struct is generated, and contains static references to 2 images.
    struct tabGlypics {
      /// Image `albums`.
      static let albums = Rswift.ImageResource(bundle: R.hostingBundle, name: "TabGlypics/albums")
      /// Image `artists`.
      static let artists = Rswift.ImageResource(bundle: R.hostingBundle, name: "TabGlypics/artists")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "albums", bundle: ..., traitCollection: ...)`
      static func albums(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tabGlypics.albums, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "artists", bundle: ..., traitCollection: ...)`
      static func artists(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tabGlypics.artists, compatibleWith: traitCollection)
      }
      #endif

      fileprivate init() {}
    }

    /// This `R.image.tab` struct is generated, and contains static references to 12 images.
    struct tab {
      /// Image `Albums`.
      static let albums = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Albums")
      /// Image `Artists`.
      static let artists = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Artists")
      /// Image `Composers`.
      static let composers = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Composers")
      /// Image `Favorites`.
      static let favorites = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Favorites")
      /// Image `Files`.
      static let files = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Files")
      /// Image `Genres`.
      static let genres = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genres")
      /// Image `More`.
      static let more = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/More")
      /// Image `Playlists`.
      static let playlists = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlists")
      /// Image `Podcasts`.
      static let podcasts = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Podcasts")
      /// Image `Search`.
      static let search = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Search")
      /// Image `Songs`.
      static let songs = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Songs")
      /// Image `soundcloud`.
      static let soundcloud = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/soundcloud")

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Albums", bundle: ..., traitCollection: ...)`
      static func albums(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.albums, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Artists", bundle: ..., traitCollection: ...)`
      static func artists(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.artists, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Composers", bundle: ..., traitCollection: ...)`
      static func composers(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.composers, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Favorites", bundle: ..., traitCollection: ...)`
      static func favorites(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.favorites, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Files", bundle: ..., traitCollection: ...)`
      static func files(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.files, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Genres", bundle: ..., traitCollection: ...)`
      static func genres(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.genres, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "More", bundle: ..., traitCollection: ...)`
      static func more(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.more, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Playlists", bundle: ..., traitCollection: ...)`
      static func playlists(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.playlists, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Podcasts", bundle: ..., traitCollection: ...)`
      static func podcasts(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.podcasts, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Search", bundle: ..., traitCollection: ...)`
      static func search(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.search, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "Songs", bundle: ..., traitCollection: ...)`
      static func songs(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.songs, compatibleWith: traitCollection)
      }
      #endif

      #if os(iOS) || os(tvOS)
      /// `UIImage(named: "soundcloud", bundle: ..., traitCollection: ...)`
      static func soundcloud(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
        return UIKit.UIImage(resource: R.image.tab.soundcloud, compatibleWith: traitCollection)
      }
      #endif

      /// This `R.image.tab.artist` struct is generated, and contains static references to 2 images.
      struct artist {
        /// Image `People Filled`.
        static let peopleFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Artist/People Filled")
        /// Image `People`.
        static let people = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Artist/People")

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "People Filled", bundle: ..., traitCollection: ...)`
        static func peopleFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.artist.peopleFilled, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "People", bundle: ..., traitCollection: ...)`
        static func people(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.artist.people, compatibleWith: traitCollection)
        }
        #endif

        fileprivate init() {}
      }

      /// This `R.image.tab.genre` struct is generated, and contains static references to 27 images.
      struct genre {
        /// Image `Alternative`.
        static let alternative = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Alternative")
        /// Image `Blues`.
        static let blues = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Blues")
        /// Image `Children’s Music`.
        static let childrenSMusic = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Children’s Music")
        /// Image `Christian & Gospel`.
        static let christianGospel = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Christian & Gospel")
        /// Image `Classical`.
        static let classical = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Classical")
        /// Image `Comedy`.
        static let comedy = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Comedy")
        /// Image `Country`.
        static let country = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Country")
        /// Image `Dance`.
        static let dance = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Dance")
        /// Image `Easy Listening`.
        static let easyListening = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Easy Listening")
        /// Image `Electronic`.
        static let electronic = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Electronic")
        /// Image `Electronica`.
        static let electronica = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Electronica")
        /// Image `Hip-Hop-Rap`.
        static let hipHopRap = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Hip-Hop-Rap")
        /// Image `Holiday`.
        static let holiday = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Holiday")
        /// Image `J-Pop`.
        static let jPop = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/J-Pop")
        /// Image `Jazz`.
        static let jazz = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Jazz")
        /// Image `K-Pop`.
        static let kPop = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/K-Pop")
        /// Image `Latino`.
        static let latino = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Latino")
        /// Image `New Age`.
        static let newAge = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/New Age")
        /// Image `Opera`.
        static let opera = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Opera")
        /// Image `Pop`.
        static let pop = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Pop")
        /// Image `R&B Soul`.
        static let rbSoul = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/R&B Soul")
        /// Image `Reggae`.
        static let reggae = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Reggae")
        /// Image `Rock`.
        static let rock = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Rock")
        /// Image `Singer-Songwriter`.
        static let singerSongwriter = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Singer-Songwriter")
        /// Image `Soundtrack`.
        static let soundtrack = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Soundtrack")
        /// Image `Vocal`.
        static let vocal = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/Vocal")
        /// Image `World`.
        static let world = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Genre/World")

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Alternative", bundle: ..., traitCollection: ...)`
        static func alternative(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.alternative, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Blues", bundle: ..., traitCollection: ...)`
        static func blues(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.blues, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Children’s Music", bundle: ..., traitCollection: ...)`
        static func childrenSMusic(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.childrenSMusic, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Christian & Gospel", bundle: ..., traitCollection: ...)`
        static func christianGospel(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.christianGospel, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Classical", bundle: ..., traitCollection: ...)`
        static func classical(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.classical, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Comedy", bundle: ..., traitCollection: ...)`
        static func comedy(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.comedy, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Country", bundle: ..., traitCollection: ...)`
        static func country(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.country, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Dance", bundle: ..., traitCollection: ...)`
        static func dance(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.dance, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Easy Listening", bundle: ..., traitCollection: ...)`
        static func easyListening(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.easyListening, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Electronic", bundle: ..., traitCollection: ...)`
        static func electronic(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.electronic, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Electronica", bundle: ..., traitCollection: ...)`
        static func electronica(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.electronica, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Hip-Hop-Rap", bundle: ..., traitCollection: ...)`
        static func hipHopRap(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.hipHopRap, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Holiday", bundle: ..., traitCollection: ...)`
        static func holiday(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.holiday, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "J-Pop", bundle: ..., traitCollection: ...)`
        static func jPop(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.jPop, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Jazz", bundle: ..., traitCollection: ...)`
        static func jazz(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.jazz, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "K-Pop", bundle: ..., traitCollection: ...)`
        static func kPop(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.kPop, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Latino", bundle: ..., traitCollection: ...)`
        static func latino(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.latino, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "New Age", bundle: ..., traitCollection: ...)`
        static func newAge(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.newAge, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Opera", bundle: ..., traitCollection: ...)`
        static func opera(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.opera, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Pop", bundle: ..., traitCollection: ...)`
        static func pop(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.pop, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "R&B Soul", bundle: ..., traitCollection: ...)`
        static func rbSoul(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.rbSoul, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Reggae", bundle: ..., traitCollection: ...)`
        static func reggae(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.reggae, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Rock", bundle: ..., traitCollection: ...)`
        static func rock(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.rock, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Singer-Songwriter", bundle: ..., traitCollection: ...)`
        static func singerSongwriter(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.singerSongwriter, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Soundtrack", bundle: ..., traitCollection: ...)`
        static func soundtrack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.soundtrack, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Vocal", bundle: ..., traitCollection: ...)`
        static func vocal(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.vocal, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "World", bundle: ..., traitCollection: ...)`
        static func world(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.genre.world, compatibleWith: traitCollection)
        }
        #endif

        fileprivate init() {}
      }

      /// This `R.image.tab.playlist` struct is generated, and contains static references to 6 images.
      struct playlist {
        /// Image `Add`.
        static let add = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/Add")
        /// Image `Genius`.
        static let genius = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/Genius")
        /// Image `MusicFolder`.
        static let musicFolder = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/MusicFolder")
        /// Image `Play`.
        static let play = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/Play")
        /// Image `Shuffle`.
        static let shuffle = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/Shuffle")
        /// Image `SmartPlaylists`.
        static let smartPlaylists = Rswift.ImageResource(bundle: R.hostingBundle, name: "Tab/Playlist/SmartPlaylists")

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Add", bundle: ..., traitCollection: ...)`
        static func add(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.add, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Genius", bundle: ..., traitCollection: ...)`
        static func genius(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.genius, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "MusicFolder", bundle: ..., traitCollection: ...)`
        static func musicFolder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.musicFolder, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Play", bundle: ..., traitCollection: ...)`
        static func play(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.play, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "Shuffle", bundle: ..., traitCollection: ...)`
        static func shuffle(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.shuffle, compatibleWith: traitCollection)
        }
        #endif

        #if os(iOS) || os(tvOS)
        /// `UIImage(named: "SmartPlaylists", bundle: ..., traitCollection: ...)`
        static func smartPlaylists(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
          return UIKit.UIImage(resource: R.image.tab.playlist.smartPlaylists, compatibleWith: traitCollection)
        }
        #endif

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 2 nibs.
  struct nib {
    /// Nib `AlbumSongCell`.
    static let albumSongCell = _R.nib._AlbumSongCell()
    /// Nib `TableViewButtonsView`.
    static let tableViewButtonsView = _R.nib._TableViewButtonsView()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AlbumSongCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.albumSongCell) instead")
    static func albumSongCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.albumSongCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TableViewButtonsView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.tableViewButtonsView) instead")
    static func tableViewButtonsView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.tableViewButtonsView)
    }
    #endif

    static func albumSongCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlbumSongCell? {
      return R.nib.albumSongCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlbumSongCell
    }

    static func tableViewButtonsView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.tableViewButtonsView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 5 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `AlbumSongCell`.
    static let albumSongCell: Rswift.ReuseIdentifier<AlbumSongCell> = Rswift.ReuseIdentifier(identifier: "AlbumSongCell")
    /// Reuse identifier `Cell`.
    static let cell: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "Cell")
    /// Reuse identifier `NoDataCell`.
    static let noDataCell: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "NoDataCell")
    /// Reuse identifier `SongCell`.
    static let songCell: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "SongCell")
    /// Reuse identifier `TextViewCell`.
    static let textViewCell: Rswift.ReuseIdentifier<UIKit.UITableViewCell> = Rswift.ReuseIdentifier(identifier: "TextViewCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 1 localization tables.
  struct string {
    /// This `R.string.localizable` struct is generated, and contains static references to 39 localization keys.
    struct localizable {
      /// en translation: %#@value@
      ///
      /// Locales: en, ko
      static let numberOfSongs = Rswift.StringResource(key: "numberOfSongs", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Added to favorites
      ///
      /// Locales: en, ko
      static let favoriteAddedToFavorites = Rswift.StringResource(key: "favorite.addedToFavorites", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: Unknown %@
      ///
      /// Locales: en, ko
      static let unknownWith = Rswift.StringResource(key: "unknown.with", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 검색
      ///
      /// Locales: en
      static let search = Rswift.StringResource(key: "search", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 그룹짓기
      ///
      /// Locales: en, ko
      static let songInfoGrouping = Rswift.StringResource(key: "songInfo.grouping", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 기본
      ///
      /// Locales: en, ko
      static let sortingDefault = Rswift.StringResource(key: "sorting.default", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 길이
      ///
      /// Locales: en, ko
      static let songInfoPlaybackDuration = Rswift.StringResource(key: "songInfo.playbackDuration", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 년도
      ///
      /// Locales: en, ko
      static let songInfoYear = Rswift.StringResource(key: "songInfo.year", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 노래
      ///
      /// Locales: en
      static let song = Rswift.StringResource(key: "song", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 노래
      ///
      /// Locales: en
      static let songs = Rswift.StringResource(key: "songs", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 노래 정보
      ///
      /// Locales: en, ko
      static let songInfo = Rswift.StringResource(key: "songInfo", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 더 보기
      ///
      /// Locales: en
      static let more = Rswift.StringResource(key: "more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 디스크 번호
      ///
      /// Locales: en, ko
      static let songInfoDiscNumber = Rswift.StringResource(key: "songInfo.discNumber", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 선호도
      ///
      /// Locales: en, ko
      static let songInfoRating = Rswift.StringResource(key: "songInfo.rating", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 아티스트
      ///
      /// Locales: en
      static let artist = Rswift.StringResource(key: "artist", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 아티스트
      ///
      /// Locales: en
      static let artists = Rswift.StringResource(key: "artists", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 아티스트
      ///
      /// Locales: en, ko
      static let songInfoArtist = Rswift.StringResource(key: "songInfo.artist", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 앨범
      ///
      /// Locales: en
      static let album = Rswift.StringResource(key: "album", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 앨범
      ///
      /// Locales: en
      static let albums = Rswift.StringResource(key: "albums", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 앨범
      ///
      /// Locales: en, ko
      static let songInfoAlbumTitle = Rswift.StringResource(key: "songInfo.albumTitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 앨범 아티스트
      ///
      /// Locales: en, ko
      static let songInfoAlbumArtist = Rswift.StringResource(key: "songInfo.albumArtist", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 작곡가
      ///
      /// Locales: en
      static let composer = Rswift.StringResource(key: "composer", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 작곡가
      ///
      /// Locales: en
      static let composers = Rswift.StringResource(key: "composers", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 작곡가
      ///
      /// Locales: en, ko
      static let songInfoComposer = Rswift.StringResource(key: "songInfo.composer", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 장르
      ///
      /// Locales: en
      static let genre = Rswift.StringResource(key: "genre", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 장르
      ///
      /// Locales: en
      static let genres = Rswift.StringResource(key: "genres", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 장르
      ///
      /// Locales: en, ko
      static let songInfoGenre = Rswift.StringResource(key: "songInfo.genre", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 재생 횟수
      ///
      /// Locales: en, ko
      static let songInfoPlayCount = Rswift.StringResource(key: "songInfo.playCount", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 재생목록
      ///
      /// Locales: en
      static let playlist = Rswift.StringResource(key: "playlist", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 재생목록
      ///
      /// Locales: en
      static let playlists = Rswift.StringResource(key: "playlists", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 제목
      ///
      /// Locales: en, ko
      static let songInfoTitle = Rswift.StringResource(key: "songInfo.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 주석
      ///
      /// Locales: en, ko
      static let songInfoComment = Rswift.StringResource(key: "songInfo.comment", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 즐겨찾기
      ///
      /// Locales: en
      static let favorite = Rswift.StringResource(key: "favorite", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 즐겨찾기
      ///
      /// Locales: en
      static let favorites = Rswift.StringResource(key: "favorites", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 최근 추가된 날짜
      ///
      /// Locales: en, ko
      static let songInfoDateAdded = Rswift.StringResource(key: "songInfo.dateAdded", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 최종 재생
      ///
      /// Locales: en, ko
      static let songInfoLastPlayedDate = Rswift.StringResource(key: "songInfo.lastPlayedDate", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 트랙
      ///
      /// Locales: en, ko
      static let songInfoTrack = Rswift.StringResource(key: "songInfo.track", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)
      /// en translation: 파일
      ///
      /// Locales: en
      static let files = Rswift.StringResource(key: "files", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en"], comment: nil)
      /// en translation: 편집 앨범
      ///
      /// Locales: en, ko
      static let songInfoCompilation = Rswift.StringResource(key: "songInfo.compilation", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ko"], comment: nil)

      /// en translation: %#@value@
      ///
      /// Locales: en, ko
      static func numberOfSongs(value value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("numberOfSongs", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "numberOfSongs"
        }

        let format = NSLocalizedString("numberOfSongs", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Added to favorites
      ///
      /// Locales: en, ko
      static func favoriteAddedToFavorites(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("favorite.addedToFavorites", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "favorite.addedToFavorites"
        }

        return NSLocalizedString("favorite.addedToFavorites", bundle: bundle, comment: "")
      }

      /// en translation: Unknown %@
      ///
      /// Locales: en, ko
      static func unknownWith(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("unknown.with", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "unknown.with"
        }

        let format = NSLocalizedString("unknown.with", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: 검색
      ///
      /// Locales: en
      static func search(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("search", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "search"
        }

        return NSLocalizedString("search", bundle: bundle, comment: "")
      }

      /// en translation: 그룹짓기
      ///
      /// Locales: en, ko
      static func songInfoGrouping(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.grouping", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.grouping"
        }

        return NSLocalizedString("songInfo.grouping", bundle: bundle, comment: "")
      }

      /// en translation: 기본
      ///
      /// Locales: en, ko
      static func sortingDefault(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("sorting.default", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "sorting.default"
        }

        return NSLocalizedString("sorting.default", bundle: bundle, comment: "")
      }

      /// en translation: 길이
      ///
      /// Locales: en, ko
      static func songInfoPlaybackDuration(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.playbackDuration", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.playbackDuration"
        }

        return NSLocalizedString("songInfo.playbackDuration", bundle: bundle, comment: "")
      }

      /// en translation: 년도
      ///
      /// Locales: en, ko
      static func songInfoYear(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.year", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.year"
        }

        return NSLocalizedString("songInfo.year", bundle: bundle, comment: "")
      }

      /// en translation: 노래
      ///
      /// Locales: en
      static func song(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("song", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "song"
        }

        return NSLocalizedString("song", bundle: bundle, comment: "")
      }

      /// en translation: 노래
      ///
      /// Locales: en
      static func songs(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songs", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songs"
        }

        return NSLocalizedString("songs", bundle: bundle, comment: "")
      }

      /// en translation: 노래 정보
      ///
      /// Locales: en, ko
      static func songInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo"
        }

        return NSLocalizedString("songInfo", bundle: bundle, comment: "")
      }

      /// en translation: 더 보기
      ///
      /// Locales: en
      static func more(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "more"
        }

        return NSLocalizedString("more", bundle: bundle, comment: "")
      }

      /// en translation: 디스크 번호
      ///
      /// Locales: en, ko
      static func songInfoDiscNumber(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.discNumber", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.discNumber"
        }

        return NSLocalizedString("songInfo.discNumber", bundle: bundle, comment: "")
      }

      /// en translation: 선호도
      ///
      /// Locales: en, ko
      static func songInfoRating(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.rating", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.rating"
        }

        return NSLocalizedString("songInfo.rating", bundle: bundle, comment: "")
      }

      /// en translation: 아티스트
      ///
      /// Locales: en
      static func artist(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("artist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "artist"
        }

        return NSLocalizedString("artist", bundle: bundle, comment: "")
      }

      /// en translation: 아티스트
      ///
      /// Locales: en
      static func artists(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("artists", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "artists"
        }

        return NSLocalizedString("artists", bundle: bundle, comment: "")
      }

      /// en translation: 아티스트
      ///
      /// Locales: en, ko
      static func songInfoArtist(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.artist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.artist"
        }

        return NSLocalizedString("songInfo.artist", bundle: bundle, comment: "")
      }

      /// en translation: 앨범
      ///
      /// Locales: en
      static func album(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("album", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "album"
        }

        return NSLocalizedString("album", bundle: bundle, comment: "")
      }

      /// en translation: 앨범
      ///
      /// Locales: en
      static func albums(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("albums", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "albums"
        }

        return NSLocalizedString("albums", bundle: bundle, comment: "")
      }

      /// en translation: 앨범
      ///
      /// Locales: en, ko
      static func songInfoAlbumTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.albumTitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.albumTitle"
        }

        return NSLocalizedString("songInfo.albumTitle", bundle: bundle, comment: "")
      }

      /// en translation: 앨범 아티스트
      ///
      /// Locales: en, ko
      static func songInfoAlbumArtist(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.albumArtist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.albumArtist"
        }

        return NSLocalizedString("songInfo.albumArtist", bundle: bundle, comment: "")
      }

      /// en translation: 작곡가
      ///
      /// Locales: en
      static func composer(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("composer", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "composer"
        }

        return NSLocalizedString("composer", bundle: bundle, comment: "")
      }

      /// en translation: 작곡가
      ///
      /// Locales: en
      static func composers(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("composers", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "composers"
        }

        return NSLocalizedString("composers", bundle: bundle, comment: "")
      }

      /// en translation: 작곡가
      ///
      /// Locales: en, ko
      static func songInfoComposer(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.composer", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.composer"
        }

        return NSLocalizedString("songInfo.composer", bundle: bundle, comment: "")
      }

      /// en translation: 장르
      ///
      /// Locales: en
      static func genre(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("genre", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "genre"
        }

        return NSLocalizedString("genre", bundle: bundle, comment: "")
      }

      /// en translation: 장르
      ///
      /// Locales: en
      static func genres(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("genres", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "genres"
        }

        return NSLocalizedString("genres", bundle: bundle, comment: "")
      }

      /// en translation: 장르
      ///
      /// Locales: en, ko
      static func songInfoGenre(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.genre", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.genre"
        }

        return NSLocalizedString("songInfo.genre", bundle: bundle, comment: "")
      }

      /// en translation: 재생 횟수
      ///
      /// Locales: en, ko
      static func songInfoPlayCount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.playCount", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.playCount"
        }

        return NSLocalizedString("songInfo.playCount", bundle: bundle, comment: "")
      }

      /// en translation: 재생목록
      ///
      /// Locales: en
      static func playlist(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("playlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "playlist"
        }

        return NSLocalizedString("playlist", bundle: bundle, comment: "")
      }

      /// en translation: 재생목록
      ///
      /// Locales: en
      static func playlists(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("playlists", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "playlists"
        }

        return NSLocalizedString("playlists", bundle: bundle, comment: "")
      }

      /// en translation: 제목
      ///
      /// Locales: en, ko
      static func songInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.title"
        }

        return NSLocalizedString("songInfo.title", bundle: bundle, comment: "")
      }

      /// en translation: 주석
      ///
      /// Locales: en, ko
      static func songInfoComment(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.comment", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.comment"
        }

        return NSLocalizedString("songInfo.comment", bundle: bundle, comment: "")
      }

      /// en translation: 즐겨찾기
      ///
      /// Locales: en
      static func favorite(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("favorite", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "favorite"
        }

        return NSLocalizedString("favorite", bundle: bundle, comment: "")
      }

      /// en translation: 즐겨찾기
      ///
      /// Locales: en
      static func favorites(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("favorites", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "favorites"
        }

        return NSLocalizedString("favorites", bundle: bundle, comment: "")
      }

      /// en translation: 최근 추가된 날짜
      ///
      /// Locales: en, ko
      static func songInfoDateAdded(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.dateAdded", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.dateAdded"
        }

        return NSLocalizedString("songInfo.dateAdded", bundle: bundle, comment: "")
      }

      /// en translation: 최종 재생
      ///
      /// Locales: en, ko
      static func songInfoLastPlayedDate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.lastPlayedDate", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.lastPlayedDate"
        }

        return NSLocalizedString("songInfo.lastPlayedDate", bundle: bundle, comment: "")
      }

      /// en translation: 트랙
      ///
      /// Locales: en, ko
      static func songInfoTrack(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.track", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.track"
        }

        return NSLocalizedString("songInfo.track", bundle: bundle, comment: "")
      }

      /// en translation: 파일
      ///
      /// Locales: en
      static func files(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("files", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "files"
        }

        return NSLocalizedString("files", bundle: bundle, comment: "")
      }

      /// en translation: 편집 앨범
      ///
      /// Locales: en, ko
      static func songInfoCompilation(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("songInfo.compilation", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "songInfo.compilation"
        }

        return NSLocalizedString("songInfo.compilation", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _TableViewButtonsView.validate()
    }

    struct _AlbumSongCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = AlbumSongCell

      let bundle = R.hostingBundle
      let identifier = "AlbumSongCell"
      let name = "AlbumSongCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> AlbumSongCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? AlbumSongCell
      }

      fileprivate init() {}
    }

    struct _TableViewButtonsView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "TableViewButtonsView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "ContextualAction/play", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ContextualAction/play' is used in nib 'TableViewButtonsView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "ContextualAction/shuffle", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'ContextualAction/shuffle' is used in nib 'TableViewButtonsView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try main.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try songInfo.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct main: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = MainTabBarController

      let bundle = R.hostingBundle
      let legacyFavoritesVC = StoryboardViewControllerResource<FavoritesTableViewController>(identifier: "LegacyFavoritesVC")
      let name = "Main"
      let nowPlayingVC = StoryboardViewControllerResource<NowPlayingVC>(identifier: "NowPlayingVC")

      func legacyFavoritesVC(_: Void = ()) -> FavoritesTableViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: legacyFavoritesVC)
      }

      func nowPlayingVC(_: Void = ()) -> NowPlayingVC? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: nowPlayingVC)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.main().legacyFavoritesVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'legacyFavoritesVC' could not be loaded from storyboard 'Main' as 'FavoritesTableViewController'.") }
        if _R.storyboard.main().nowPlayingVC() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'nowPlayingVC' could not be loaded from storyboard 'Main' as 'NowPlayingVC'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct songInfo: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = BaseNC

      let bundle = R.hostingBundle
      let name = "SongInfo"
      let songInfo = StoryboardViewControllerResource<BaseNC>(identifier: "SongInfo")

      func songInfo(_: Void = ()) -> BaseNC? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: songInfo)
      }

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
        if _R.storyboard.songInfo().songInfo() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'songInfo' could not be loaded from storyboard 'SongInfo' as 'BaseNC'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
